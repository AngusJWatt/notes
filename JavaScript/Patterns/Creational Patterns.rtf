{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\vieww14740\viewh15500\viewkind0
\deftab720
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\f0\fs22 \cf0 \ul \ulc0 Singleton\
\ulnone \
	The singleton pattern describes the case where a single instance of an object is created, and any further attempts to instantiate that object will return only the original object.\
	Since JavaScript objects are instantiated without the requirement of calling a class, as is the case with other languages such as Java, the singleton pattern is not necessarily as useful. However, it can be useful in the case where modules are involved, as there may be a desire to only have one version of the desired object per module. The most basic implementation of this is as follows:\
\

\f1\i 	/*singleton.js*/
\f0\i0 \

\f1\i 	const data = \{\};\
	export const getData = () => data;\

\f0\i0 \
	When this is imported into another module, the function 
\f1\i getData
\f0\i0  returns the same instance of 
\f1\i data
\f0\i0  every time it is called. Hence, we would see the following behaviour:\
\

\f1\i 	/*test.js*/\
	import \{ getData \} from \'91./singleton.js\'92;\
	const dataFoo = getData();\
	const dataBar = getData();\
	dataFoo.value = \'91Hello World!\'92;\
	console.log(dataBar.value);\
	/* Hello World!*/\

\f0\i0 \
\ul Factory Pattern\
\ulnone \
	The factory pattern simplifies the creation of objects which may be difficult to instantiate by encapsulating the creation process of many different objects in a single method.\
\

\f1\i 	/*factory.js*/\
	const createFoo = props => (\{\'85\});\
	const createBar = props => (\{\'85\});\
	const factory = type => \{\
		const fooProps = \{\'85\};\
		const barProps = \{\'85\};\
		if (type === \'91foo\'92) \{\
			return createFoo(fooProps);\
		\}\
		if (type === \'91bar\'92) \{\
\pard\pardeftab720\sl276\slmult1\partightenfactor0
\cf0 			return createBar(barProps);\
		\}\
		return null;\
\pard\pardeftab720\sl276\slmult1\partightenfactor0
\cf0 	\};\

\f0\i0 \
\ul Abstract Factory Method\ulnone \
\
	The principle behind the factory method can be iterated upon, allowing for multiple factories to be called upon in a single method.\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\f1\i \cf0 	/*abstract-factory.js*/\
	const fooFactory = type => (\{\'85\});\
	const barFactory = type => (\{\'85\});\
	const abstractFactory = (factory, type) => \{\
		if (factory === \'91foo\'92) \{\
			return fooFactory(type);\
		\}\
		if (factory === \'91bar\'92) \{\
			return fooFactory(type);\
		\}\
		return null;\
	\};}